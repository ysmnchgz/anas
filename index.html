<!DOCTYPE html>
<html lang="fr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Anas = prout</title>

  <!-- Cute cursive font -->
  <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@600&display=swap" rel="stylesheet">

  <style>
    /* Base styling */
    body {
      margin: 0;
      padding: 0;
      overflow: hidden;
      font-family: 'Dancing Script', cursive;
      background-color: black;
    }

    canvas {
      display: block;
      width: 100vw;
      height: 100vh;
    }

    /* Sweet message */
    .message {
      position: absolute;
      left: 50%;
      top: calc(50% + 30px);
      transform: translate(-50%, -50%);
      color: #ffb6c1;
      max-width: 80vw;
      word-wrap: break-word;
      font-size: 1.6em;   
      top: calc(50% - 10px);  /* Keep centered */
      text-align: center;
      opacity: 0;
      line-height: 1.5;
      animation: fadeIn 2s ease-in-out 8s forwards;
      text-shadow: 0 0 10px #ff4d6d, 0 0 20px #ff4d6d;
      z-index: 10;
      padding: 0 20px;
    }

    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: translate(-50%, -50%) scale(0.8);
      }
      to {
        opacity: 1;
        transform: translate(-50%, -50%) scale(1);
      }
    }

    /* Glitch background overlay */
    .glitch-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      display: none;
      z-index: 999;
      background: repeating-linear-gradient(
        0deg,
        #ff00ff 0px,
        #00ffff 5px,
        #ffff00 10px,
        #000000 15px
      );
      animation: glitch-bg 0.3s infinite;
    }

    @keyframes glitch-bg {
      0% { background-position: 0 0; }
      50% { background-position: 10px 10px; }
      100% { background-position: 0 0; }
    }

    /* Final image + text */
    .final-image {
      display: none;
      position: fixed;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 1000;
      text-align: center;
      color: white;
    }

    .final-image img {
      max-width: 300px;
      width: 80vw;
    }

    .final-image .final-text {
      margin-top: 30px;
      font-size: 2.5em;
      animation: colorChange 2s infinite;
      text-shadow: 0 0 10px black;
    }

    @keyframes colorChange {
      0% { color: #ff4d6d; }
      25% { color: #00ffff; }
      50% { color: #ffff00; }
      75% { color: #ff00ff; }
      100% { color: #ffffff; }
    }
  </style>
</head>

<body>
  <canvas id="canvas"></canvas>

  <!-- Message before glitch -->
  <div class="message">
    T'es beau, t'es fort, t'es capable<br />
    Yasmine (je t'aime)
  </div>

  <!-- Glitch and final text -->
  <div class="glitch-overlay" id="glitchOverlay"></div>
  <div class="final-image" id="finalImage">
    <img src="confu.png" alt="confused image" />
    <div class="final-text">Tu fous quoi encore ici?<br />
        C’est fini big</div>
  </div>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;

    window.addEventListener('resize', () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
    });

    class Particle {
      constructor(x, y, vx, vy, color, life, targetX = null, targetY = null) {
        this.x = x;
        this.y = y;
        this.vx = vx;
        this.vy = vy;
        this.color = color;
        this.life = life;
        this.maxLife = life;
        this.targetX = targetX;
        this.targetY = targetY;
        this.gravity = 0.1;
        this.size = Math.random() * 3 + 2;
        this.isFormingHeart = targetX !== null;
        this.formingSpeed = 0.02;
      }

      update() {
        if (this.isFormingHeart) {
          const dx = this.targetX - this.x;
          const dy = this.targetY - this.y;
          this.x += dx * this.formingSpeed;
          this.y += dy * this.formingSpeed;
        } else {
          this.x += this.vx;
          this.y += this.vy;
          this.vy += this.gravity;
        }
        this.life--;
      }

      draw() {
        const alpha = this.life / this.maxLife;
        ctx.save();
        ctx.globalAlpha = alpha;
        ctx.fillStyle = this.color;
        ctx.shadowBlur = 15;
        ctx.shadowColor = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.fill();
        ctx.restore();
      }
    }

    const particles = [];
    const fireworkColors = ['#ff4d6d', '#ff6b85', '#ff8fa3', '#ffc1cc', '#ffffff', '#cce6ff', '#ffcccc'];
    let animationTime = 0;
    let heartFormed = false;

    // Fireworks
    function createFirework(x, y) {
      const count = 30;
      for (let i = 0; i < count; i++) {
        const angle = (Math.PI * 2 * i) / count;
        const speed = Math.random() * 6 + 3;
        const vx = Math.cos(angle) * speed;
        const vy = Math.sin(angle) * speed;
        const color = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
        const life = Math.random() * 60 + 40;
        particles.push(new Particle(x, y, vx, vy, color, life));
      }
    }

    // Heart shape math
    function getHeartShape(cx, cy, size) {
      const points = [];
      const n = 120;
      for (let i = 0; i < n; i++) {
        const t = (i / n) * Math.PI * 2;
        const x = cx + size * (16 * Math.pow(Math.sin(t), 3));
        const y = cy + size * -(13 * Math.cos(t) - 5 * Math.cos(2 * t) - 2 * Math.cos(3 * t) - Math.cos(4 * t));
        points.push({ x, y });
      }
      return points;
    }

    // Draw the heart
    function createHeart() {
      const cx = canvas.width / 2;
      const cy = canvas.height / 2;
      const size = Math.min(canvas.width, canvas.height) / 38; // Responsive sizing
      const heartPoints = getHeartShape(cx, cy, size);
      heartPoints.forEach((point, i) => {
        setTimeout(() => {
          for (let j = 0; j < 4; j++) {
            const sx = Math.random() * canvas.width;
            const sy = Math.random() * canvas.height;
            const color = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
            const life = 500;
            particles.push(new Particle(sx, sy, 0, 0, color, life, point.x, point.y));
          }
        }, i * 15);
      });
      heartFormed = true;
    }

    // Main animation loop
    function animate() {
      ctx.fillStyle = 'rgba(0, 0, 0, 0.15)';
      ctx.fillRect(0, 0, canvas.width, canvas.height);
      animationTime++;

      if (animationTime < 180 && Math.random() < 0.07) {
        const x = Math.random() * canvas.width;
        const y = Math.random() * canvas.height;
        createFirework(x, y);
      }

      if (animationTime === 180 && !heartFormed) {
        createHeart();
      }

      for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        p.update();
        p.draw();
        if (p.life <= 0) {
          particles.splice(i, 1);
        }
      }

      requestAnimationFrame(animate);
    }

    // Timing the ending sequence
    setTimeout(() => {
      document.querySelector('canvas').style.display = 'none';
      document.querySelector('.message').style.display = 'none';
      const glitch = document.getElementById('glitchOverlay');
      const final = document.getElementById('finalImage');
      glitch.style.display = 'block';

      setTimeout(() => {
        final.style.display = 'block';
      }, 1500);
    }, 14000); // Increased from 12000 → now gives 2 extra seconds

    // Start animation
    animate();
  </script>
</body>
</html>

